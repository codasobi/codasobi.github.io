[{"content":"\n輸入網址和域名解析 當你在瀏覽器中輸入一個網址（例如 www.example.com），瀏覽器首先會進行域名解析，將域名轉換成對應的 IP 地址。 網址包含「通訊協定（Protocol）」、「網域（Domain）」、「路徑（Path）」等資訊 在現代瀏覽器中，如果輸入的內容看似未包含協定前綴、網域或 IP，瀏覽器可能將其視為搜尋字詞，而非不合法的 URL。若內容不完整但能被自動修正，瀏覽器可能自動補全（如自動加上 \u0026ldquo;https://\u0026rdquo; 或 \u0026ldquo;.com\u0026rdquo; 等）。 瀏覽器會查詢 DNS (Domain Name System) 伺服器，以獲取域名對應的 IP 地址。 DNS 是用來儲存網域對應到的 IP 位址的服務。 建立網路連線 瀏覽器獲得伺服器的 IP 地址後，會使用 TCP 建立網路連線。 TCP 使用一個被稱為 \u0026ldquo;三次握手\u0026rdquo; 的過程來建立一個連線。在這個過程中，兩個通訊方互相交換信息，確認連線的有效性。具體過程如下： 用戶端發送一個包含 SYN（Synchronize）標誌的封包，表示希望與伺服器建立連線。 伺服器接收這個封包後，回應一個包含 SYN 和 ACK（Acknowledge）標誌的封包，表達同意建立連線。 用戶端再回應一個包含 ACK 標誌的封包，確認連線已經建立。 資料傳輸：連接建立後，雙方可以開始傳輸資料。TCP 通過順序號、確認號和重發機制來確保資料的可靠傳輸。 如果網址是 HTTPS 協議，還需要建立 TLS（傳輸層安全協議）加密連接，以確保通訊的安全性。 發送 HTTP 請求 瀏覽器主要是辨識 URI 中的協定部分，如 HTTP 或 HTTPS。這決定了瀏覽器如何與伺服器通訊。 若 URI 中沒有指定協定，瀏覽器會預設使用 HTTP。 連接建立後，瀏覽器向伺服器發送 HTTP 請求，通常是 GET 請求。 HTTP 請求包含標頭、查詢參數(用 \u0026ldquo;?\u0026rdquo; 表示，附加在 URL 末尾)、Cookie 和其他必要信息。 標頭包含有關請求的信息，包括： Content-Type：說明請求或響應的內容類型，例如 \u0026ldquo;application/json\u0026rdquo;、\u0026ldquo;text/html\u0026rdquo;、\u0026ldquo;multipart/form-data\u0026rdquo; 等。 User-Agent：描述用戶端應用程式，例如瀏覽器版本。 Authorization：攜帶認證信息，例如 \u0026ldquo;Bearer token\u0026rdquo;。 Accept：表示用戶端希望接收的資料類型，例如 \u0026ldquo;application/json\u0026rdquo;。 Host：指定目標主機的域名。 其他常用標頭：如 \u0026ldquo;Content-Length\u0026rdquo;、\u0026ldquo;Cookie\u0026rdquo;、\u0026ldquo;Referer\u0026rdquo; 等。 伺服器處理請求 伺服器接收到 HTTP 請求後，會根據請求內容進行處理，例如查找資源、執行後端代碼、查詢資料庫等。 一旦處理完畢，伺服器會生成 HTTP 回應，通常包括狀態代碼、回應標頭和可能的回應體（例如 HTML 文件）。 接收和處理 HTTP 回應 瀏覽器接收到 HTTP 回應後，檢查狀態代碼、標頭和正文。 狀態碼：例如 200 (成功)，404 (未找到)，500 (內部伺服器錯誤) 等。 響應標頭：提供與響應相關的元資料。 響應正文：包含請求的實際內容，例如網頁、JSON 資料等。 如果回應有效，瀏覽器將進行進一步的處理。若需要其他資源，如 CSS、JavaScript 或圖片，可能會發送額外的請求。 解析和渲染網頁 瀏覽器開始解析 HTML 文件，構建 DOM（文檔對象模型）。 解析HTML DOM 瀏覽器將收到的 HTML 文檔轉換為一個結構化的樹狀模型，稱為 DOM（Document Object Model）。 DOM 代表網頁的結構和內容，每個 HTML 標籤被解析為一個節點。 解析順序：瀏覽器按順序從上到下解析 HTML 標籤。這個過程包括識別標籤的名稱、屬性和嵌套關係。 解析 CSS CSS 規則：瀏覽器提取 CSS 文件或內嵌在 HTML 中的 CSS 規則，這些規則定義了網頁的樣式，包括布局、顏色、字體等。 CSSOM（CSS Object Model）：瀏覽器將 CSS 規則轉換為一個樹狀結構，以便與 DOM 進行交互。CSSOM 與 DOM 結合，用於計算元素的最終樣式。 構建 Render Tree 結合 DOM 和 CSSOM：瀏覽器將 DOM 和 CSSOM 結合，生成一個 Render Tree。這個樹只包含可視元素（例如，隱藏的元素不在 Render Tree 中），並且結合了樣式信息。 計算布局：瀏覽器計算每個元素在網頁上的位置和尺寸，這個過程稱為布局（layout）。 繪製和渲染 繪製（Painting）：瀏覽器將 Render Tree 中的每個元素轉換為繪製指令，並將這些指令發送到瀏覽器的渲染引擎。繪製過程包括填充顏色、繪製文本、圖片等。 渲染（Rendering）：渲染引擎將繪製的結果輸出到螢幕上，最終渲染網頁。 處理 JavaScript 在網頁渲染後，瀏覽器會執行 JavaScript 代碼。 解析和執行 JavaScript：如果網頁包含 JavaScript，瀏覽器將解析和執行這些腳本。這可能會影響 DOM 和 CSSOM，導致重新構建 Render Tree。 事件處理：JavaScript 可以處理用戶交互（如點擊、滑動等），並更新網頁內容。 重繪和重布局 重繪（Repaint）：如果樣式發生改變，可能會導致重繪。 重布局（Reflow）：如果元素的位置或尺寸改變，可能需要重新計算布局並進行重繪。\n維護和持續更新 當網頁顯示後，瀏覽器持續處理用戶交互。 此外，瀏覽器可能會使用 AJAX 或 WebSocket 與伺服器持續通訊，確保網頁內容動態更新。 註記 cache 在實際向 DNS 發出請求之前，瀏覽器會依序檢查以下 cache，如果找不到就會往下一層 cache 找： 瀏覽器 cache \u0026gt; OS cache \u0026gt; Router cache \u0026gt; ISP cache 如果這些 cache 中沒有該網域，ISP 會發起 DNS lookup：ISP 的 DNS server 會問其他 name server，name server 又會問其他 name server，直到找到- 這種搜尋方式是一種遞迴搜尋 (recursive search)，而發起搜尋的 ISP DNS server 稱為 DNS recursor。 TCP TCP連線關閉：當通訊結束時，TCP 使用一個稱為 \u0026ldquo;四次握手\u0026rdquo; 的過程來關閉連線，以確保所有的資料都已經傳輸並確認。這個過程通常是： 一方發送一個包含 FIN（Finish）標誌的封包，表示希望關閉連線。 另一方回應一個包含 ACK 標誌的封包。 第二方再發送一個包含 FIN 標誌的封包，表示準備關閉連線。 第一方回應一個包含 ACK 標誌的封包，連線關閉。 HTTP request GET：從伺服器獲取資源。通常用於請求網頁、圖片等。 POST：向伺服器提交資料。常用於表單提交和 API 請求。 PUT：更新伺服器上的資源。 DELETE：刪除伺服器上的資源。 HEAD：類似於 GET，但僅返回標頭，不返回實際內容。 其他方法還有 OPTIONS、PATCH、TRACE、CONNECT 等。 參考資料 經典前端面試題：從瀏覽器網址列輸入 URL 按下 enter 發生了什麼？\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2024-04-30T22:00:00Z","image":"https://codasobi.github.com/p/from-url-to-webpage/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://codasobi.github.com/p/from-url-to-webpage/","title":"從輸入網址列到畫面出現經歷了哪些過程？"},{"content":"#1 Reversed Strings\nDESCRIPTION: Complete the solution so that it reverses the string passed into it.\n1 2 \u0026#39;world\u0026#39; =\u0026gt; \u0026#39;dlrow\u0026#39; \u0026#39;word\u0026#39; =\u0026gt; \u0026#39;drow\u0026#39; SOLUTION:\nIf input is a string, then reverse it. 1 2 3 def solution(string): if isinstance(string, str): return string[::-1] #2 Convert string to camel case\nDESCRIPTION:\nComplete the method/function so that it converts dash/underscore delimited words into camel casing. The first word within the output should be capitalized only if the original word was capitalized (known as Upper Camel Case, also often referred to as Pascal case). The next words should be always capitalized. 1 2 3 \u0026#34;the-stealth-warrior\u0026#34; =\u0026gt; \u0026#34;theStealthWarrior\u0026#34; \u0026#34;The_Stealth_Warrior\u0026#34; =\u0026gt; \u0026#34;TheStealthWarrior\u0026#34; \u0026#34;The_Stealth-Warrior\u0026#34; =\u0026gt; \u0026#34;TheStealthWarrior\u0026#34; SOLUTION:\nKeep first word unchanged, and capitalized the rest of the words Need to unify split character \u0026lsquo;-\u0026rsquo;, \u0026lsquo;_\u0026rsquo; Split to array, capitalize then join 1 2 3 4 5 6 7 def to_camel_case(text): if isinstance(text, str): # unify \u0026#39;-\u0026#39; to \u0026#39;_\u0026#39; and split words = text.replace(\u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;).split(\u0026#39;_\u0026#39;) camel_words = [words[0]] + [word.capitalize() for word in words[1:]] result = (\u0026#39;\u0026#39;).join(camel_words) return result #3 Jenny\u0026rsquo;s secret message\nDESCRIPTION:\nJenny has written a function that returns a greeting for a user. However, she\u0026rsquo;s in love with Johnny, and would like to greet him slightly different. 1 2 3 \u0026#34;Johnny\u0026#34; =\u0026gt; \u0026#34;Hello, my love!\u0026#34; \u0026#34;Mary\u0026#34; =\u0026gt; \u0026#34;Hello, Mary\u0026#34; \u0026#34;Oliver\u0026#34; =\u0026gt; \u0026#34;Hello, Oliver\u0026#34; 1 2 3 4 5 def greet(name): if name == \u0026#34;Johnny\u0026#34;: return \u0026#34;Hello, my love!\u0026#34; else: return \u0026#34;Hello, {name}!\u0026#34;.format(name=name) #4 Changing letters\nDESCRIPTION:\nWhen provided with a String, capitalize all vowels 1 \u0026#34;Hello World!\u0026#34; =\u0026gt; \u0026#34;HEllO WOrld!\u0026#34; SOLUTION:\nDefine vowels Create an blank [] to put char Use for loop to find vowel, change to upper case then add into [] Change [] to string 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # [expression for item in iterable if condition] def swap(str): vowel = \u0026#39;aeiou\u0026#39; result = \u0026#39;\u0026#39;.join([char.upper() if char.lower() in vowel else char for char in str]) return result #if before for is creating # for loop def swap(str): vowel = \u0026#39;aeiou\u0026#39; result = [] for char in str: if char.lower() in vowel: result.append(char.upper()) else: result.append(char) return \u0026#39;\u0026#39;.join(result) #5 Disemvowel Trolls\nDESCRIPTION:\nYour task is to write a function that takes a string and return a new string with all vowels removed. 1 \u0026#34;This website is for losers LOL!\u0026#34; =\u0026gt; \u0026#34;Ths wbst s fr lsrs LL!\u0026#34; SOLUTION:\nDefine vowels Use a for loop to find char other than vowels and join together 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # maketrans def disemvowel(string): vowel = \u0026#39;aeiou\u0026#39; table = str.maketrans(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;, vowel) return string.lower().translate(table) # for loop def disemvowel(string): vowels = \u0026#39;aeiou\u0026#39; result = \u0026#39;\u0026#39; for char in string: if char.lower() not in vowels: result += char return result # (expression for item in iterable if condition) def disemvowel(string): vowels = \u0026#39;aeiou\u0026#39; result = \u0026#39;\u0026#39;.join(char for char in string if char.lower() not in vowels) return result #if after for is filtering #6 Find the Capitals\nDESCRIPTION:\nComplete the method that takes a sequence of objects with two keys each: country or state, and capital. Keys may be symbols or strings. The method should return an array of sentences declaring the state or country and its capital. 1 2 3 [{\u0026#39;state\u0026#39;: \u0026#39;Maine\u0026#39;, \u0026#39;capital\u0026#39;: \u0026#39;Augusta\u0026#39;}] =\u0026gt; [\u0026#34;The capital of Maine is Augusta\u0026#34;] [{\u0026#39;country\u0026#39; : \u0026#39;Spain\u0026#39;, \u0026#39;capital\u0026#39; : \u0026#39;Madrid\u0026#39;}] =\u0026gt; [\u0026#34;The capital of Spain is Madrid\u0026#34;] [{\u0026#34;state\u0026#34; : \u0026#39;Maine\u0026#39;, \u0026#39;capital\u0026#39;: \u0026#39;Augusta\u0026#39;}, {\u0026#39;country\u0026#39;: \u0026#39;Spain\u0026#39;, \u0026#34;capital\u0026#34; : \u0026#34;Madrid\u0026#34;}] =\u0026gt; [\u0026#34;The capital of Maine is Augusta\u0026#34;, \u0026#34;The capital of Spain is Madrid\u0026#34;] SOLUTION:\nCreate a [] to put in the sentence 1 2 3 4 5 6 7 8 def capital(capitals): sentences = [] for item in capitals: if \u0026#39;state\u0026#39; in item: sentences.append(f\u0026#39;The capital of {item[\u0026#34;state\u0026#34;]} is {item[\u0026#34;capital\u0026#34;]}\u0026#39;) elif \u0026#39;country\u0026#39; in item: sentences.append(f\u0026#39;The capital of {item[\u0026#34;country\u0026#34;]} is {item[\u0026#34;capital\u0026#34;]}\u0026#39;) return sentences #7 Even or Odd\nDESCRIPTION:\nCreate a function that takes an integer as an argument and returns \u0026ldquo;Even\u0026rdquo; for even numbers or \u0026ldquo;Odd\u0026rdquo; for odd numbers. SOLUTION:\nUse % 2 to justify even or odd 1 2 3 4 5 def even_or_odd(number): if number % 2 == 0: return \u0026#39;Even\u0026#39; else: return \u0026#39;Odd\u0026#39; #8 Sum of positive\nDESCRIPTION:\nYou get an array of numbers, return the sum of all of the positives ones. 1 Example [1,-4,7,12] =\u0026gt; 1 + 7 + 12 = 20 SOLUTION:\nCreate a sum var Use a for loop, if num is positive then add it. 1 2 3 4 5 6 def positive_sum(arr): sum = 0 for num in arr: if num \u0026gt; 0: sum += num return sum #9 You\u0026rsquo;re a square!\nDESCRIPTION:\nGiven an integral number, determine if it\u0026rsquo;s a square number: 1 2 3 4 5 6 -1 =\u0026gt; false 0 =\u0026gt; true 3 =\u0026gt; false 4 =\u0026gt; true 25 =\u0026gt; true 26 =\u0026gt; false SOLUTION:\nSquare number is \u0026gt;= 0 Use math.sqrt to check root If result is int, then it is a square number 1 2 3 4 5 6 import math def is_square(n): if n \u0026gt;= 0: return math.sqrt(n).is_integer() else: return False #10 Keep Hydrated\nDESCRIPTION:\nNathan knows it is important to stay hydrated, he drinks 0.5 litres of water per hour of cycling. You get given the time in hours and you need to return the number of litres Nathan will drink, rounded to the smallest value. 1 2 3 time(hr) = 3 =\u0026gt; litres = 1 time(hr) = 6.7 =\u0026gt; litres = 3 time(hr) = 11.8 =\u0026gt; litres = 5 SOLUTION:\n3 * 0.5 = 1.5 =\u0026gt; 1 6.7 * 0.5 = 3.35 =\u0026gt; 3 11.8 * 0.5 = 5.9 =\u0026gt; 5 Use math.floor() 1 2 3 4 import math def litres(time): # 1 hour need 0.5 liter return math.floor(time * 0.5) #11 Calculate Average\nDESCRIPTION:\nWrite a function which calculates the average of the numbers in a given list. Empty arrays should return 0. SOLUTION:\nempty array, lens(number) will be 0 (ZeroDivisionError: division by zero) use sum() and lens() 1 2 3 4 5 def find_average(numbers): if len(numbers) == 0: return 0 else: return sum(numbers) / len(numbers) #12 Abbreviate a Two Word Name\nDESCRIPTION:\nWrite a function to convert a name into initials. This kata strictly takes two words with one space in between them. The output should be two capital letters with a dot separating them. 1 2 Sam Harris =\u0026gt; S.H patrick feeney =\u0026gt; P.F SOLUTION:\nsplit name to [] upper first char and join with \u0026lsquo;.\u0026rsquo; 1 2 3 4 def abbrev_name(name): parts = name.split(\u0026#39; \u0026#39;) abbr = \u0026#39;.\u0026#39;.join(part[0].upper() for part in parts) return abbr #13 Categorize New Member\nTo be a senior, a member must be at least 55 years old and have a handicap greater than 7. In this croquet club, handicaps range from -2 to +26; the better the player the lower the handicap. Input will consist of a list of pairs. Each pair contains information for a single potential member. Information consists of an integer for the person\u0026rsquo;s \u0026ldquo;age\u0026rdquo; and an integer for the person\u0026rsquo;s \u0026ldquo;handicap\u0026rdquo;. Output will consist of a list of string values (in Haskell and C: Open or Senior) stating whether the respective member is to be placed in the senior or open category. 1 2 input = [[18, 20], [45, 2], [61, 12], [37, 6], [21, 21], [78, 9]] output = [\u0026#34;Open\u0026#34;, \u0026#34;Open\u0026#34;, \u0026#34;Senior\u0026#34;, \u0026#34;Open\u0026#34;, \u0026#34;Open\u0026#34;, \u0026#34;Senior\u0026#34;] SOLUTION:\nCreate a [] Use a for loop, if match senior\u0026rsquo;s condition then append \u0026lsquo;Senior\u0026rsquo; Other append \u0026lsquo;Open\u0026rsquo; 1 2 3 4 5 6 7 8 def open_or_senior(data): result = [] for item in data: if item[0] \u0026gt;= 55 and item[1] \u0026gt; 7: result.append(\u0026#39;Senior\u0026#39;) else: result.append(\u0026#39;Open\u0026#39;) return result #14 Find the smallest integer in the array\nDESCRIPTION:\nGiven an array of integers your solution should find the smallest integer. 1 2 Given [34, 15, 88, 2] your solution will return 2 Given [34, -345, -1, 100] your solution will return -345 SOLUTION:\nUse min() to find the int 1 2 def find_smallest_int(arr): return min(arr) #15 Counting Duplicates\nDESCRIPTION:\nWrite a function that will return the count of distinct case-insensitive alphabetic characters and numeric digits that occur more than once in the input string. The input string can be assumed to contain only alphabets (both uppercase and lowercase) and numeric digits. 1 2 3 4 5 6 7 \u0026#34;abcde\u0026#34; =\u0026gt; 0 # no characters repeats more than once \u0026#34;aabbcde\u0026#34; =\u0026gt; 2 # \u0026#39;a\u0026#39; and \u0026#39;b\u0026#39; \u0026#34;aabBcde\u0026#34; =\u0026gt; 2 # \u0026#39;a\u0026#39; occurs twice and \u0026#39;b\u0026#39; twice (`b` and `B`) \u0026#34;indivisibility\u0026#34; =\u0026gt; 1 # \u0026#39;i\u0026#39; occurs six times \u0026#34;Indivisibilities\u0026#34; =\u0026gt; 2 # \u0026#39;i\u0026#39; occurs seven times and \u0026#39;s\u0026#39; occurs twice \u0026#34;aA11\u0026#34; =\u0026gt; 2 # \u0026#39;a\u0026#39; and \u0026#39;1\u0026#39; \u0026#34;ABBA\u0026#34; =\u0026gt; 2 # \u0026#39;A\u0026#39; and \u0026#39;B\u0026#39; each occur twice SOLUTION:\nCreate a {} to count chars Count if key\u0026rsquo;s value \u0026gt; 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def duplicate_count(text): counter = {} for char in text.lower(): if char in counter: counter[char] += 1 else: counter[char] = 1 count = 0 for item in counter.values(): if item \u0026gt; 1: count += 1 # count = sum(1 for item in counter.values() if item \u0026gt; 1 ) return count #16 Counting Sheep (https://www.codewars.com/kata/54edbc7200b811e956000556)\nDESCRIPTION:\nConsider an array/list of sheep where some sheep may be missing from their place. We need a function that counts the number of sheep present in the array (true means present). Hint: Don\u0026rsquo;t forget to check for bad values like null/undefined 1 2 3 4 5 6 [True, True, True, False, True, True, True, True , True, False, True, False, True, False, False, True , True, True, True, True , False, False, True, True] =\u0026gt; 17 SOLUTION:\nUse a for loop, if True, count + 1 1 2 3 4 5 6 7 8 9 def count_sheeps(sheep): count = 0 for status in sheep: if status: count += 1 else: continue # count = sum(1 for status in sheep if status) return count #17 Unique In Order\nDESCRIPTION:\nImplement the function unique_in_order which takes as argument a sequence and returns a list of items without any elements with the same value next to each other and preserving the original order of elements. 1 2 3 4 unique_in_order(\u0026#39;AAAABBBCCDAABBB\u0026#39;) =\u0026gt; [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;] unique_in_order(\u0026#39;ABBCcAD\u0026#39;) =\u0026gt; [\u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;D\u0026#39;] unique_in_order([1, 2, 2, 3, 3]) =\u0026gt; [1, 2, 3] unique_in_order((1, 2, 2, 3, 3)) =\u0026gt; [1, 2, 3] SOLUTION:\nUse groupby to group, and return the keys 1 2 3 from itertools import groupby def unique_in_order(sequence): return [key for key, group in groupby(sequence)] #18 Find the Difference in Age\nDESCRIPTION:\nAt the annual family gathering, the family likes to find the oldest living family member’s age and the youngest family member’s age and calculate the difference between them. You will be given an array of all the family members\u0026rsquo; ages, in any order. The ages will be given in whole numbers, so a baby of 5 months, will have an ascribed ‘age’ of 0. Return a new array (a tuple in Python) with [youngest age, oldest age, difference between the youngest and oldest age]. 1 [16, 22, 31, 44, 3, 38, 27, 41, 88] =\u0026gt; (3, 88, 85)) SOLUTION:\nUse max() and min() to calculate and return a tuple 1 2 def difference_in_ages(ages): return (min(ages), max(ages), max(ages) - min(ages)) #19 Array diff\nDESCRIPTION:\nYour goal in this kata is to implement a difference function, which subtracts one list from another and returns the result. It should remove all values from list a, which are present in list b keeping their order. 1 2 array_diff([1,2],[1]) == [2] array_diff([1,2,2,2,3],[2]) == [1,3] SOLUTION:\n1 2 def array_diff(a, b): return [item for item in a if item not in b] #20 Century From Year\nDESCRIPTION:\nGiven a year, return the century it is in. 1 2 3 4 5 1705 --\u0026gt; 18 1900 --\u0026gt; 19 1601 --\u0026gt; 17 2000 --\u0026gt; 20 2742 --\u0026gt; 28 SOLUTION:\nif the num could not be devided by 100, then will round up 1 2 3 import math def century(year): return math.ceil(year / 100) #21 Isograms\nDESCRIPTION:\nAn isogram is a word that has no repeating letters, consecutive or non-consecutive. Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. Ignore letter case. 1 2 3 \u0026#34;Dermatoglyphics\u0026#34; =\u0026gt; true \u0026#34;aba\u0026#34; =\u0026gt; false \u0026#34;moOse\u0026#34; =\u0026gt; false (ignore letter case) SOLUTION:\nChange all char to lower case. Compare string length with set(string) length 1 2 3 4 5 6 def is_isogram(string): string = string.lower() if len(string) == len(set(string)): return True else: return False #22 Two to One\nDESCRIPTION:\nTake 2 strings s1 and s2 including only letters from a to z. Return a new sorted string, the longest possible, containing distinct letters each taken only once coming from s1 or s2. SOLUTION:\nCombine 2 string Use set to remove the repeated Sort the set and return a string 1 2 def longest(s1, s2): return \u0026#39;\u0026#39;.join(sorted(set(s1+s2))) ","date":"2024-05-17T07:00:00Z","permalink":"https://codasobi.github.com/p/codewar/","title":"Codewars practice"},{"content":"為什麼需要域名解析？ 每個連上網際網路的裝置都有一個唯一的 IP 地址，這是一串數字，用來識別和連接網路上的裝置。對於一般使用者來說，記住 IP 地址可能非常困難。域名解析的目的是讓我們可以使用簡單易記的名稱（域名）來訪問網站，而不用記住一連串的數字。\n域名解析的運作方式 域名解析主要依靠域名系統（DNS），這是一個分散式的系統，用來管理域名與 IP 地址之間的對應關係。以下是域名解析的主要步驟：\nDNS 解析器：當你在瀏覽器中輸入域名時，DNS 解析器會開始工作。它負責查詢並找到對應的 IP 地址。\n尋找根域名伺服器：DNS 解析器會先詢問根域名伺服器，根域名伺服器是 DNS 系統的最上層節點，它可以指引查詢下一步該去哪個伺服器。\n尋找頂級域名 (TLD) 伺服器：根域名伺服器會把請求轉發到負責特定頂級域名（例如 \u0026ldquo;.com\u0026rdquo; 或 \u0026ldquo;.org\u0026rdquo;）的伺服器。\n尋找權威 DNS 伺服器：頂級域名伺服器再將請求轉給該域名的權威 DNS 伺服器，這些伺服器包含了該域名對應的 IP 地址。\n返回 IP 地址：權威 DNS 伺服器提供對應的 IP 地址，並將其傳回 DNS 解析器，再由解析器傳給瀏覽器或其他應用程式。\n連接到目標伺服器：當瀏覽器得到 IP 地址後，它可以連接到目標伺服器，並開始請求網頁內容或其他服務。\n不同類型的域名解析 域名解析有不同的類型，主要依據查詢的方式和目的來分類。常見的幾種類型包括：\n正向解析：將域名轉換成 IP 地址。 反向解析：將 IP 地址轉換成域名，通常用於網路排錯或其他技術應用。 遞歸查詢：由 DNS 解析器負責完整的查詢過程，從根伺服器到權威伺服器。 迭代查詢：每個伺服器只返回下一個查詢的方向，而不提供最終答案。 結論 域名解析是網際網路中不可或缺的過程，它讓我們可以使用易記的域名來訪問網站，而不用記住複雜的 IP 地址。DNS 透過一系列的查詢步驟，將域名與相應的 IP 地址對應起來，讓網際網路的運作更為順暢且方便。\n","date":"2024-05-08T20:00:00Z","permalink":"https://codasobi.github.com/p/dns-lookup/","title":"域名解析（DNS Lookup） 的簡介"},{"content":"什麼是 TCP？ TCP（Transmission Control Protocol，傳輸控制協定）是一個面向連線的、可靠的協定。這意味著在傳輸資料之前，TCP 需要建立一個連線，並保證資料在傳輸過程中的完整性和順序。\nTCP 的主要特點 三次握手：在傳輸資料之前，TCP 需要通過三次握手建立連線。這個過程確保了雙方都準備好傳輸資料。\n可靠性：TCP 通過確認和重傳機制確保資料的完整性。如果封包在傳輸過程中丟失或損壞，TCP 會自動重傳。 順序性：TCP 保證封包按順序到達。這對於需要有序資料的應用程式非常重要。 流量控制：TCP 使用流量控制來防止資料傳輸過快，避免網路擁塞。 擁塞控制：TCP 通過監控網路流量，動態調整傳輸速率，以避免網路過載。 TCP 的應用場景 TCP 適合需要可靠性和順序的應用程式。例如，網頁瀏覽、電子郵件、文件傳輸等。這些應用程式需要確保所有資料都完整且有序地到達。\n什麼是 UDP？ UDP（User Datagram Protocol 使用者資料封包協定）是一個無連線的、簡單的協定。與 TCP 不同，UDP 不需要建立連線，也不保證資料的可靠性和順序。\nUDP 的主要特點 無連線：UDP 不需要建立連線。封包可以隨時發送，不需要三次握手。 不可靠性：UDP 不提供資料的確認和重傳。這意味著封包可能會在傳輸過程中丟失或損壞。 低延遲：由於沒有建立連接和確認機制，UDP 的傳輸延遲較低。 簡單：UDP 的協定結構比 TCP 簡單，這使得它在某些情況下更高效。 UDP 的應用場景 UDP 適合對延遲敏感、不需要可靠性的應用程式。例如，語音和視訊、線上遊戲、直播等。在這些應用中，低延遲比資料的完整性更重要，並且可以容忍少量的資料丟失。\nTCP 和 UDP 的差異 特性 TCP UDP 連接方式 面向連線（需要三次握手） 無連線 可靠性 提供確認和重傳 不提供確認或重傳 順序性 保證資料按順序到達 不保證資料順序 傳輸延遲 相對較高 低延遲 流量控制 有流量控制 無流量控制 擁塞控制 有擁塞控制 無擁塞控制 開銷 較高 較低 主要用途 需要可靠性和順序的應用 對延遲敏感的應用 TCP 和 UDP 是網路通信中的兩個重要協定，各自有不同的特點和應用場景。理解它們的差異，可以幫助你在不同的情況下選擇合適的協定。\n","date":"2024-05-08T18:00:00Z","permalink":"https://codasobi.github.com/p/tcp-vs-udp/","title":"TCP 和 UDP 的簡介"}]